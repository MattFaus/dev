import argparse
import re
import pprint
import operator

# Global object to keep parsed command-line arguments
cmd_args = None

def main():
	init_args()
	
	data = parse_file(cmd_args.path)
	for pair in sorted(data.iteritems(), key=operator.itemgetter(1), reverse=True):
		video_url = "https://www.youtube.com/watch?v={0}".format(pair[0][3:])
		amara_url = \
		"http://www.universalsubtitles.org/api/1.0/subtitles/?language=en&video_url={0}".format(video_url)
		print "{0},{1},{2},{3}".format(
			pair[0], 
			pair[1],
			video_url,
			amara_url)


def parse_file(path):
	"""Parses the invalid timestamp data out of a report.
	The report is generated by running 
		'zgrep SUBTITLE-INVALID-TIMESTAMP *log.gz'
	against a folder in analytics:~/kalogs/2013/*

	Returns:
		A dictionary of (subtitle_id, num_bad_times)"""

	data = dict()
	raw_file = open(path)
	regex_invalid_time = \
		r"!SUBTITLE-INVALID-TIMESTAMP! id=(?P<id>.+) num_bad_times=(?P<num>\d+)"

	for line in raw_file:
		m = re.search(regex_invalid_time, line)

		if m:
			the_id = m.group('id')
			num = int(m.group('num'))

			if data.has_key(the_id):
				print 'Warning, id occurred twice:', the_id

			data[the_id] = num
		else:
			print 'Did not understand', line[:-1]

	return data	


def init_args():
	parser = argparse.ArgumentParser()
	parser.add_argument("path")

	# TODO, don't use a global, translate this into a class
	# and use an instance variable
	global cmd_args 
	cmd_args = parser.parse_args()


if __name__ == "__main__":
    main()
